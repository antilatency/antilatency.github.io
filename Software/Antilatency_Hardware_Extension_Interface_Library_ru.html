<!DOCTYPE html><html lang="ru"><head><link rel="stylesheet" href="https://antilatency.github.io/320113C27AB734C7F4F44E36086E7858.css"><script src="https://antilatency.github.io/B8BF46F6D36DB77FF8F3CB2E891274A3.js"></script><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes"><title>Antilatency Hardware Extension Interface Library</title></head><body class="TemplateRegularMaterial"><script>Behaviour.Initialize("TemplateLeftSideMenu",800,64)</script><nav class="menu LeftSideMenu" id="LeftSideMenu"><a class="text AntilatencyLogo" href="https://antilatency.github.io/Root/Index_ru.html" title="Компания мечты" style="font-family: 'antilatency' !important; color: ;"><span style="color: #ACC435">a</span><span style="color: #000000">l</span></a><a class="text" href="https://antilatency.github.io/Root/Index_ru.html" title="Компания мечты">Antilatency</a><a class="text" href="https://antilatency.github.io/Store/PresetEditor_ru.html" title="Welcome to Antilatency store!">Store</a><a class="text" href="https://antilatency.github.io/Sdk/Configurator_ru.html" title="На этой странице вы сможите &quot;Приготовить&quot; Sdk, выбрав платформу и добавив ингредиенты на ваш вкус">Sdk</a><a class="text" href="https://antilatency.github.io/Terms/Antilatency_Device_Network_ru.html" title="Библиотека для комуникации с устройствами Antilatency. Позволяет находить устройства среди подключенных, отслеживать подключение новых устройств, запускать задачи на устройствах, а также обновлять прошивку.">Antilatency Device Network</a><a class="text" href="https://antilatency.github.io/Hardware/Alt_ru.html" title="На этой странице странице пока побудут некоторые примеры использования движка.">Alt</a><a class="text" href="https://antilatency.github.io/Internal/Debug_ru.html" title="На этой странице странице некоторые примеры использования движка.">Debug</a><a class="text" href="https://antilatency.github.io/Csml/CsmlPredefined/Diagnostics_ru.html" title="This page provide diagnostics information about website. This page is auto generated.">Diagnostics</a><a class="text" href="https://antilatency.github.io/Software/Antilatency_Service_ru.html" title="Служебное приложение Antilatency для управления настройками трекинга и обновления устройств">Antilatency Service</a></nav><div id="Content" class="Content"><div class="header"><h1 class="title">Antilatency Hardware Extension Interface Library</h1><div class="text">Библиотека для <a class="text" href="https://antilatency.github.io/Terms/Antilatency_Hardware_Extension_Interface_ru.html" title="Реализаци доступа к GPIO сокета через UsbTypeC разъём с помощью Antilatency Extension Board и Antilatency Hardware Extension Interface Library">Antilatency Hardware Extension Interface</a></div></div><div class="section"><h2 class="title" id="Использование_библиотеки">Использование библиотеки<a class="link" href="#Использование_библиотеки" title="Heading anchor"></a></h2><ol class="List Ordered"><li><div class="text">Загрузка библиотеки.</div></li><li><div class="text">Получение ILibrary.</div></li><li><div class="text">Получение ICotaskConstructor.</div></li><li><div class="text">Запуск таска с помощью startTask().</div></li><li><div class="text">Декларирование режимов работы нужных пинов, получение соответствующих интерфейсов(IInputPin, IOutputPin и т.д.)</div></li><li><div class="text">Перевод таска в режим <b>Run</b> с помощью run().</div></li><li><div class="text">Работа с полученными ранее интерфейсами(IInputPin, IOutputPin и т.д.)</div></li></ol></div><div class="section"><h2 class="title" id="IInputPin">IInputPin<a class="link" href="#IInputPin" title="Heading anchor"></a></h2><div class="csharp code"><pre>
<span class="keyword">public</span> <span class="keyword">interface</span> IInputPin : Antilatency.InterfaceContract.IInterface {
    Interop.PinState getState();
}
</pre></div><div class="text"><code>getState()</code> возвращает актуальное состояние пина(изменяется не чаще, чем раз в 5мс).</div></div><div class="section"><h2 class="title" id="IOutputPin">IOutputPin<a class="link" href="#IOutputPin" title="Heading anchor"></a></h2><div class="csharp code"><pre>
<span class="keyword">public</span> <span class="keyword">interface</span> IOutputPin : Antilatency.InterfaceContract.IInterface {
    <span class="keyword">void</span> setState(Interop.PinState state);
    Interop.PinState getState();
}
</pre></div><div class="text"><code>getState()</code> возвращает последние состояние, модифицированное с помощью <code>setState()</code>(запрос на устройство не отправляется).</div><div class="text"><code>setState()</code> отправляет устройству запрос на изменение состояния пина. Кидает исключение, если не удалось отправить запрос.</div></div><div class="section"><h2 class="title" id="IAnalogPin">IAnalogPin<a class="link" href="#IAnalogPin" title="Heading anchor"></a></h2><div class="csharp code"><pre>
<span class="keyword">public</span> <span class="keyword">interface</span> IAnalogPin : Antilatency.InterfaceContract.IInterface {
    <span class="keyword">float</span> getValue();
}
</pre></div><div class="text"><code>getValue()</code> возвращает актуальное напряжение на пине в вольтах.</div></div><div class="section"><h2 class="title" id="IPulseCounterPin">IPulseCounterPin<a class="link" href="#IPulseCounterPin" title="Heading anchor"></a></h2><div class="csharp code"><pre>
<span class="keyword">public</span> <span class="keyword">interface</span> IPulseCounterPin : Antilatency.InterfaceContract.IInterface {
    UInt16 getValue();
}
</pre></div><div class="text"><code>getValue()</code> возвращает количество импульсов за последний период.</div></div><div class="section"><h2 class="title" id="IPwmPin">IPwmPin<a class="link" href="#IPwmPin" title="Heading anchor"></a></h2><div class="csharp code"><pre>
<span class="keyword">public</span> <span class="keyword">interface</span> IPwmPin : Antilatency.InterfaceContract.IInterface {
    <span class="keyword">void</span> setDuty(<span class="keyword">float</span> value);
    <span class="keyword">float</span> getDuty();
    <span class="keyword">uint</span> getFrequency();
}
</pre></div><div class="text"><code>setDuty()</code> отправляет устройству запрос на изменение скважности ШИМ сигнала. Кидает исключение, если не удалось отправить запрос.</div><div class="text"><code>getDuty()</code> возвращает текущую скважность ШИМ сигнала.(без запроса к устройству)</div><div class="text"><code>getFrequency()</code> возвращает актуальную частоту ШИМ сигнала.</div><div class="text">Для более высокой частоты <code>duty</code> будет иметь больше градаций. Но сама частота может быть установлена менее точно(для некоторых значений). Частоты из ряда 20, 100, 500, 1000, 2000, 5000, 10000 герц будут установлены со 100% точностью. Узнать реальную частоту и скважность можно с помощью <code>getFrequency()</code> и <code>getDuty()</code> соответственно.</div></div><div class="panel info"><div class="text">До перехода таска в состояние <b>Run</b> все методы данных интерфейсов будут возвращать значение по умолчанию.</div></div><div class="section"><h2 class="title" id="ICotask">ICotask<a class="link" href="#ICotask" title="Heading anchor"></a></h2><div class="csharp code"><pre>
<span class="keyword">public</span> <span class="keyword">interface</span> ICotask : Antilatency.DeviceNetwork.ICotask {
    IInputPin createInputPin(Interop.Pins pin);
    IOutputPin createOutputPin(Interop.Pins pin, Interop.PinState initialState);
    IAnalogPin createAnalogPin(Interop.Pins pin, <span class="keyword">uint</span> refreshIntervalMs);
    IPulseCounterPin createPulseCounterPin(Interop.Pins pin, <span class="keyword">uint</span> refreshIntervalMs);
    IPwmPin createPwmPin(Interop.Pins pin, <span class="keyword">uint</span> frequency, <span class="keyword">float</span> initialDuty);
    <span class="keyword">void</span> run();
}
</pre></div><div class="panel info"><div class="text">Методы по созданию пинов только формируют таблицу инициализации, которая будет отправлена на устройство в методе <code>run()</code>.</div></div><div class="text">Сразу после запуска таск находится в состоянии <b>Init</b>. Только в этом состоянии работают методы по созданию пинов.</div><div class="text"><code>createInputPin()</code> создаёт пин в режиме входа.</div><div class="text"><code>createOutputPin()</code> создаёт пин в режиме выхода. Необходимо указать состояние, которое примет пин сразу после инициализации.</div><div class="text"><code>createAnalogPin()</code> создаёт пин в режиме аналогового входа. <code>refreshIntervalMs</code> - время(в миллисекундах) обновления значение. <b>Todo add from api</b>См. Constants::AnalogMinRefreshIntervalMs и Constants::AnalogMaxRefreshIntervalMs.</div><div class="text"><code>createPulseCounterPin()</code> создаёт пин в режиме счетчика импульсов. <code>refreshIntervalMs</code> - время(в миллисекундах) обновления значение. <b>Todo add from api</b> См. Constants::PulseCounterMinRefreshIntervalMs и Constants::PulseCounterMaxRefreshIntervalMs.</div><div class="panel info"><div class="text">На текущий момент поддерживается только одинаковое время обновления для двух пинов в режиме счетчика импульсов.</div></div><div class="text"><code>createPwmPin()</code> создаёт пин в режиме ШИМ выхода.<code>frequency</code> - частота сигнала в герцах <b>Todo add from api</b> См. Constants::PwmMinFrequency и Constants::PwmMaxFrequency. <code>initialDuty</code> - скважность ШИМ сигнала сразу после инициализации в интервале [0;1].</div><div class="panel info"><div class="text">Частота для всех ШИМ пинов должна быть одинаковая.</div></div><div class="text">Причины исключений, которые могут быть кинуты в методах создания пинов:</div><ol class="List Ordered"><li><div class="text">Был уже вызван метод run().</div></li><li><div class="text">Указанный пин уже используется.</div></li><li><div class="text">Указанный пин не поддерживает требуемый режим.</div></li><li><div class="text">Refresh interval/frequency не входит в допустимый диапазон(см. Constants).</div></li><li><div class="text">Уже создано максимальное количество пинов данного типа.</div></li><li><div class="text">Указаны разные refresh interval для пинов в режиме счетчика импульсов или frequency для ШИМ пинов.</div></li></ol><div class="text"><code>run()</code> отправляет на устройство сформированную таблицу инициализации и ждёт подтверждения. Таск переходит в режим <b>Run</b>. Гарантируется, что после выхода из метода, будут получены актуальные состояния всех пинов в режиме входа и аналогового входа, а также установлены начальные состояния всех пинов в режиме выхода.</div><div class="text">После перехода в режим <b>Run</b> можно пользоваться необходимыми методами из полученных ранее интерфейсов(<code>IInputPin</code>, <code>IOutputPin</code> и т.д.).</div><div class="text">После завершения таска, все пины деинициализируются и переходят в высокоимпедансное состояние(Hi-Z).</div></div></div><nav class="language-menu"><a class="text" href="https://antilatency.github.io/Software/Antilatency_Hardware_Extension_Interface_Library_en.html" title="Библиотека для Antilatency Hardware Extension Interface">English</a><a class="text" href="https://antilatency.github.io/Software/Antilatency_Hardware_Extension_Interface_Library_ru.html" title="Библиотека для Antilatency Hardware Extension Interface">Русский</a><a class="text" href="https://antilatency.github.io/Software/Antilatency_Hardware_Extension_Interface_Library_zh.html" title="Библиотека для Antilatency Hardware Extension Interface">中文</a></nav></body></html>